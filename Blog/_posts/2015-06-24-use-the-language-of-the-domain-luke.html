---
layout: post
title: Use the Language of the Domain, Luke
disqus_url: http://optimizedprogrammer.com/blog/use-the-language-of-the-domain-luke
guid: http://optimizedprogrammer.com:80/blog/use-the-language-of-the-domain-luke
---

<p>I recently <a href="http://www.dotnetrocks.com/default.aspx?showNum=1151" target="_blank">did an interview for one of my favorite podcasts</a>, <a href="http://www.dotnetrocks.com/Default.aspx" target="_blank">.NET Rocks</a>.&nbsp; In the episode, I talked with <a href="https://twitter.com/richcampbell" target="_blank">Richard Campbell</a> and <a href="http://carlfranklin.com/" target="_blank">Carl Franklin</a> about <a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank">Domain-Driven Design</a>, why I think it is so appealing, what I see as a misplaced emphasis in most of the materials I’ve heard regarding it, and what I think the emphasis should be instead.&nbsp; I really like the way the interview went and the way it turned out.&nbsp; You should listen to it.</p> <p>In that interview, I laid bare my position on the ideas that are important to Domain-Driven Design.&nbsp; The points of emphasis I see (and from what I can gather, they are consistent with the views of <a href="http://domainlanguage.com/" target="_blank">Eric Evans</a> on this), are these:</p> <ul> <li>The Ubiquitous Language</li> <li>Bounded Contexts</li> <li>Core Domain</li> <li>Domain Events</li> <li>Aggregates, Entities, Value Objects, and the stuff closer to the implementation Evans recommends</li></ul><a href="http://optimizedprogrammer.com/Media/OptimizedProgrammer/Windows-Live-Writer/4fe3ee77e8a0_BA8D/1961_AMC_PRfoto_Designers_2.jpg"><img title="1961_AMC_PRfoto_Designers" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="1961_AMC_PRfoto_Designers" src="http://optimizedprogrammer.com/Media/OptimizedProgrammer/Windows-Live-Writer/4fe3ee77e8a0_BA8D/1961_AMC_PRfoto_Designers_thumb.jpg" width="553" height="484"></a> <p>&nbsp;</p> <p>The first 4 things on this list are, to me, what make up Domain-Driven Design.&nbsp; Using these concepts, you can compose a system from autonomous pieces and make them play nice together without having dependencies requiring coordinated development, deployment, and testing (though end-to-end testing is something that should and must happen, it’s not a dependency for independent operation of teams).&nbsp; This is where DDD has enormous value.&nbsp; The fifth item is advice on how to build your system inside a bounded context.&nbsp; This information is nice and in some bounded contexts it prescribes practices and patterns useful in managing the modeling of the problem.&nbsp; It’s not always the best way to build the guts of a particular bounded context.&nbsp; It’s a tool in the toolbox that should be used where and when appropriate.&nbsp; It’s not the core of what makes DDD appealing.</p> <p>One of the things I brought up in the interview on .NET Rocks was something I saw in a presentation recently at the <a href="http://www.meetup.com/dotnet-109/" target="_blank">Denver .NET Meetup</a>.&nbsp; <a href="http://thepaulrayner.com/" target="_blank">Paul Rayner</a> was giving a presentation about using <a href="http://www.specflow.org/" target="_blank">SpecFlow</a> with Visual Studio to practice <a href="https://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank">Behavior-Driven Development</a>.&nbsp; He was asserting that features should be expressed in the terms of the business (the Ubiquitous Language, to use the vocabulary of Domain-Driven Design) and to avoid technical terms like requests and responses and HTTP status codes and user interface terms like .&nbsp; There was some disagreement in the audience as to whether rigor on this was really necessary, or if just talking in terms of the user interface is good enough.&nbsp; It seems to me it’s pretty broadly agreed and obvious that in BDD, technical terms are bad, but the prohibition on user interface elements is received much less warmly.</p> <p>The intent of Behavior-Driven Development is, first and foremost, communication.&nbsp; The collaboration of technical experts and domain experts is facilitated by the practice.&nbsp; This is why Behavior-Driven Development is useful.&nbsp; I have heard many people say that they are practicing BDD simply because they are using <a href="https://cucumber.io/" target="_blank">Cucumber</a> or one of its ports on another tech stack.&nbsp; This, though, is not the case.&nbsp; If you are using Cucumber or a derivative to automate tests without constructing features as a team, you are writing tests, not describing behaviors or creating <a href="https://en.wikipedia.org/wiki/Specification_by_example" target="_blank">specification by example</a>.&nbsp; It might be <a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank">TDD</a> (that’s not even guaranteed given only that you are testing), but it’s not BDD.&nbsp; <a href="http://dannorth.net/2012/05/31/bdd-is-like-tdd-if/" target="_blank">The collaboration that makes BDD useful is what makes it BDD</a>.&nbsp; Not coincidentally, this is also why Domain-Driven Design is useful.&nbsp; As an alternative to technical persons meeting in a room with business persons and then going away with their understandings and interpretations to design, test, and implement software, DDD and BDD emphasize whole teams working together to specify what the software should do.&nbsp; In <a href="http://dannorth.net/introducing-bdd/" target="_blank">his post where he coined the term Behavior-Driven Development</a>, Dan North (ok, I’ll go with Behaviour-Driven as a tip of the hat to Dan North) references Eric Evans’s book and explicitly uses the DDD term “ubiquitous language”.&nbsp; This is the thing that makes BDD an evolutionary step beyond Test-Driven Development.&nbsp; Instead of writing tests to help the design of the system emerge, practitioners of Behaviour-Driven Development collaborate with domain experts to specify the <em>intent</em> of the system.</p> <p>In describing intent, we are talking about activities.&nbsp; We are talking about actions users will take and the expected outcomes.&nbsp; We’re not talking about users, though.&nbsp; We’re talking about accountants, or oil rig workers, or dolphins (the users of your system have personas, they aren’t just users – if your users are dolphins, please let me know, that sounds interesting).&nbsp; A user wants to do something.&nbsp; That something does not involve putting a row in a database table or requesting a page or clicking a button.&nbsp; A student wants to consume a lecture.&nbsp; A lawyer wants to file a brief (I don’t know what that means, but if I was designing a system for lawyers to use to file briefs, it would be my job to know).</p> <p>There is not a binary criterion for distinguishing good and bad features.&nbsp; It is a continuum with many shades of gray (more than 50) in between.&nbsp; Describing the behavior of a user interacting with a system with user interface terms is certainly an improvement over using technical terms.&nbsp; Describing the behavior of a user interacting with a system with domain terms is certainly an improvement over using user interface terms.</p> <p>I am reminded of a <a href="http://blogs.lessthandot.com/index.php/EnterpriseDev/application-lifecycle-management/using-specflow-to/" target="_blank">post I read years ago about using Selenium to drive a browser in integration tests using SpecFlow</a>.&nbsp; Because the intent of the post was to show test automation with SpecFlow and Selenium working together, we can forgive that the language of the feature is given in terms of screens and pages.&nbsp; It illustrates, though, an attempt at describing the feature in the language of the domain that falls just a bit short.&nbsp; Having a feature that looks like this:</p><pre>Feature: Cart Total<br>&nbsp;&nbsp;&nbsp; As a shopper <br>&nbsp;&nbsp;&nbsp; I want to see my cart total on every screen <br>&nbsp;&nbsp;&nbsp; So I don't have to leave my current page to verify it's contents<br>&nbsp;<br><br>@UI<br>Scenario: Empty Cart<br>&nbsp;&nbsp;&nbsp; Given I have the Home Page open<br>&nbsp;&nbsp;&nbsp; Then the cart is empty<br>&nbsp;<br>@UI<br>Scenario: Add an Item<br>&nbsp;&nbsp;&nbsp; Given I have the Home Page open<br>&nbsp;&nbsp;&nbsp; And I select a genre from the left<br>&nbsp;&nbsp;&nbsp; And I select an album from the genre page<br>&nbsp;&nbsp;&nbsp; When I add the album to my cart<br>&nbsp;&nbsp;&nbsp; Then the cart has a total of 1</pre>
<p>is so close to what we really want.&nbsp; It uses domain language and describes what the user wants to accomplish.&nbsp; It still involves too much web page lingo, though.&nbsp; Try this alternative:</p><pre>Feature: Cart Total<br>&nbsp;&nbsp;&nbsp; As a shopper <br>&nbsp;&nbsp;&nbsp; I want to see my cart total<br>&nbsp;&nbsp;&nbsp; So I can make informed decisions about what I want to buy<br>
<br><br>@UI<br>Scenario: Empty Cart<br>&nbsp;&nbsp;&nbsp; Given I have a new cart<br>&nbsp;&nbsp;&nbsp; Then the cart is empty<br>&nbsp;<br>@UI<br>Scenario: Add an Item<br>&nbsp;&nbsp;&nbsp; Given I have a new cart<br>&nbsp;&nbsp;&nbsp; When I add the album “Bad Hair Day” to my cart<br>&nbsp;&nbsp;&nbsp; Then the cart has a total of 1</pre>
<p>Do you see the difference?&nbsp; Removing information about page context and what I see in a user interface and focusing instead on the vocabulary of the domain leads to a more readable specification.&nbsp; Yes, spelling out step-by-step the pages and clicks a user must navigate to perform a task maps nicely to lines of code in step definitions.&nbsp; Is this really what you want, though?&nbsp; Do you want a specification that reads like a test, or an example depicting a real-world use of the real-world process (in this case, buying music) you are modeling with software.&nbsp; I’ll take the latter.&nbsp; It serves as a better specification and as better documentation and when a domain expert looks at that document, they see something they could have written (and ideally, they did participate in writing it).&nbsp; This is where the exercise of building software becomes an exercise in determining what users really want and an exercise in delivering value to delighted customers.&nbsp; Focusing on the problem domain instead of the technological medium yields a much clearer picture of what it is that is sought that is more accessible to both business and technical personnel.</p>
