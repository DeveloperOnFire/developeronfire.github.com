---
layout: post
title: Lamentations Over “Of the Web” vs “On the Web”
disqus_url: http://optimizedprogrammer.com/blog/lamentations-over-of-the-web-vs-on-the-web-
guid: http://optimizedprogrammer.com:80/blog/lamentations-over-of-the-web-vs-on-the-web-
---

<p>Jeremy Keith wrote a thoughtful <a href="https://adactio.com/journal/8245">blog post recently with a the clever title “Angular Momentum.”</a>&nbsp; During reading it, I found myself nodding in agreement and then disagreeing and reproaching myself for being taken in and then oscillating between the two.&nbsp; I finally landed on thinking that he had written something thought-provoking and insightful and with a degree of subjectivity with room for differing thoughts.&nbsp; It’s a post I both like and dislike.</p> <p>He started out with an epic description of enterprise software in saying that it is “big, bloated, and buggy.”&nbsp; Who can disagree with that?&nbsp; He also describes it as an instance of the cat food problem – the idea that cat food is advertised to and purchased by buyers who are not the actual end user of the product – in that decisions about technology stacks and platforms and tools are often made by the people with the money or management titles, not the people with the technical expertise and those doing the work – and certainly not by those using the system.&nbsp; He then says that <a href="https://angularjs.org/">AngularJS</a> falls into this abhorrent category of enterprise software.&nbsp; This was at first and uncomfortable characterization at which I recoiled.&nbsp; I then slowed down and took in his larger point and I appreciate it, though I don’t embrace it completely and I think there needs to be some room to allow for compromise and nuance.</p> <p><a href="http://optimizedprogrammer.com/Media/OptimizedProgrammer/Windows-Live-Writer/A-Reaction_CA99/Fatty_watching_himself_on_TV_2.jpg"><img title="Fatty_watching_himself_on_TV" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="Fatty_watching_himself_on_TV" src="http://optimizedprogrammer.com/Media/OptimizedProgrammer/Windows-Live-Writer/A-Reaction_CA99/Fatty_watching_himself_on_TV_thumb.jpg" width="512" height="683"></a></p> <p>He goes on to describe how the ethos of the web is one of universality and that the idea of Internet is that everything should be accessible to everyone.&nbsp; He deftly describes minimal experiences in less-capable browsers with upgraded fireworks for those with the modern powerhouse browser – the idea that began with graceful degradation and then evolved into <a href="http://ageekandhisblog.com/graceful-degradation-vs-progressive-enhancement/">turning graceful degradation on its head and instead making it progressive enhancement</a>.&nbsp; He says that this is the way of the web and that sophisticated frameworks relying on users having only the most recent and rocking browsers are contrary to what the Web is all about.&nbsp; To this I say both yes and no.&nbsp; Yes, the ideal is that a site work in any browser its user chooses, but it is time-and-money-consuming to support all the quirks of the many browsers out there.&nbsp; Testing to assure something works under multiple browsers running on differing operating systems is a career unto itself.&nbsp; The degree to which compatibility with multiple browsers is a requirement for a given application is a function of the requirements for that application.&nbsp; There are some problems for which the best solution is software for which you are simply going to need a keyboard and a lot of screen space to effectively use the thing.&nbsp; It would be silly to worry about mobile browsers for such a case.&nbsp; There are also the old desktop browsers – the likes of Internet Explorer 6 and 7.&nbsp; You know, the ones that thumbed their collective noses at web standards and acted as though having a large market share meant they dictated the standard and didn’t need to comply (which was, unfortunately, true).&nbsp; There’s also mobile Safari that <a href="http://arstechnica.com/gadgets/2014/08/with-mobile-safari-as-the-new-ie6-microsoft-modifies-windows-phone/">uses market share as a club to beat user experience to death and make standards irrelevant.</a>&nbsp; Supporting all these browsers is fine and good, but it doesn’t come without a cost and that cost doesn’t always make sense.&nbsp; If I write a browser and you start using it, does that make someone else’s website responsible for making sure it works in my browser?&nbsp; There’s a limit to all this.</p> <p>That said, the idea that functionality that can be served with simple HTTP requests and server-generated/served markup, style, and script for devices and browsers with limited resources is an argument that has virtue.&nbsp; I still stand, though, by the assertion that it depends on the application and intended audience.&nbsp; Sometimes it makes sense not to serve someone in order to serve someone else better.&nbsp; At other times, giving everyone an experience is better than giving some a top-notch experience for a few.&nbsp; Ultimately, it depends.&nbsp; What is the intent of the application?&nbsp; Universal access is a reasonable goal for much of what is offered on the web, and it’s a virtue for those things for which it makes sense, but I see no reason universal access needs to be, well, universal.&nbsp; There is room in the world and on the Internet for Web as universal access and for Web as a delivery mechanism with conditions.&nbsp; The beauty of the Internet is the absence of gatekeepers saying how you must deliver your content and products, not a dictum on how it must be done.</p> <p>Additionally, both Jeremy and the sources to which he links are trying to draw lines between back-end and front-end developers like it’s some kind of Jedi vs. Sith battle with virtuous JavaScript guys and well-meaning but naïve back-enders.&nbsp; I don’t get it.&nbsp; What value is there in having a spitting contest about who has the more challenging of problems?&nbsp; Delivering value to clients, customers, and end users should be the focus of the exercise of software creation and not a wrestling match for which concerns matter more.&nbsp; Additionally, a seasoned software professional should be comfortable dealing with all the challenges and facets of delivering a solution.&nbsp; Maybe in decades past it made sense to say that a person was a front-end or a back-end person, but today a developer needs to be comfortable in the browser and in a database.&nbsp; Trying to partition applications into horizontally sliced tiers where a “front-end” developer can do the web application and a “back-end” developer can do business logic and data access is antiquated and sub-optimal.&nbsp; Responsibility for a vertical slice of system functionality - delivering entire features that users can use with full responsibility - makes more sense than artificial borders around pseudo-technical divisions.&nbsp; Also, the assertion that choices of technology stack for functionality living on the server are unimportant is bordering on offensive.&nbsp; Yes, familiarity with certain tools and platforms and languages matter and can matter more than the actual features of those tools and platforms and languages.&nbsp; I’ll assume that’s what he meant – if something else, I will have to disagree and even acknowledging that doesn’t mean that some platforms and languages are better for certain problems than others.&nbsp; I don’t think this is particularly different with regard to code that runs in the browser.&nbsp; Choosing to use a framework and if so, which one(s) has consequences that matter, but can be overshadowed by the productivity and delivered product coming from a developer who know how to use what they have chosen to use.&nbsp; There are learning curves in any technology no matter where it runs.</p> <p>That Jeremy calls Angular “Enterprise Software” in the pejorative because clients often come to technical architects/designers/implementers with design and technical direction already in mind is not a rational criticism.&nbsp; He’s pointing out a real problem, but pointing at a bystander and not the perpetrator.&nbsp; Yes, those requesting technical expertise for a problem should come with a problem description and not a solution design.&nbsp; Yes, this is seldom the approach of those with a problem because everyone thinks they have a solution.&nbsp; Everybody has ideas about what the solution looks like and that’s often how they communicate the problem.&nbsp; An exceptional technical person in the role of architect or whatever title is attached is one who can cut through the noise and extract the actual problem from pseudo-solutions and recommend a direction for a technical solution that may or may not follow the lines of what was in the head of the client and tactfully persuade.&nbsp; This has nothing to do with AngularJS.&nbsp; Yes, Angular may be one of those solutions given by a client, just like any other framework or library or pattern.&nbsp; It may happen more frequently than with others.&nbsp; Jeremy acknowledges that his experience of Angular being pushed on him more often than other technologies is anecdotal and deserves recognition of that, but still blames Angular for that experience.&nbsp; A knife can be used to commit a murder, but that does not mean using knives is a bad choice or that they are not “of the tool drawer.”&nbsp; It simply means that if someone approaches you wanting to use a knife to murder you, you are better off being elsewhere.&nbsp; If a potential client/customer/manager comes to you with a problem and they are giving you the solution you are to implement without any flexibility for listening to your expertise and getting to the root of the problem to solve, you are better off being elsewhere.&nbsp; It may be that a mandated solution includes AngularJS or gerbils on wheels powering rendering, but these technologies are not the culprit in the wrong choice being made for the wrong reason, they are just the tools that were chosen by the wrong people at the wrong time without the right effort put into identifying the problem before arriving at the solution.&nbsp; I agree it’s a mistake to make implementation decisions before deciding on what the thing does, but I don’t think that problem is isolated to any framework, library, or platform.&nbsp; It’s a near-universal human condition and a near-universal human fault.</p> <p>I like Jeremy’s emphasis on subjectivity in how one views the web and that philosophy is important and that one should act in accordance with principle.&nbsp; Ultimately, though, I think Jeremy is making the same mistake for which he is criticizing AngularJS (though it’s not really a criticism of AngularJS, as I have pointed out, but the choosing of AngularJS (or anything else) without considering whether it is a good fit for the problem) – he is demanding universal access for all web application without thinking through what it is that the application is trying to deliver.&nbsp; Ok, he’s not demanding it, but strongly asserting that universal access is a matter of principle and not one of the right fit for the right problem and that violation of universal access is a question of virtue.&nbsp; On this I disagree.&nbsp; Accessibility choices, like technical choices, should be made with an eye – nay, with both eyes – on the problem for which the software is intended as a solution.</p>
